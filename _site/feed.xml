<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="http://www.j10.monster/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.j10.monster/" rel="alternate" type="text/html" /><updated>2021-04-08T18:32:52+08:00</updated><id>http://www.j10.monster/feed.xml</id><title type="html">Just1earnm0re</title><author><name>Just1earnm0re</name></author><entry><title type="html">Liquid</title><link href="http://www.j10.monster/2021/04/07/liquid.html" rel="alternate" type="text/html" title="Liquid" /><published>2021-04-07T00:00:00+08:00</published><updated>2021-04-07T00:00:00+08:00</updated><id>http://www.j10.monster/2021/04/07/liquid</id><content type="html" xml:base="http://www.j10.monster/2021/04/07/liquid.html">&lt;!-- &lt;!DOCTYPE html&gt; --&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;Home&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;hello world! 222 3 &lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;</content><author><name>Just1earnm0re</name></author><summary type="html">Home hello world! 222 3</summary></entry><entry><title type="html">Abc</title><link href="http://www.j10.monster/2021/04/06/abc.html" rel="alternate" type="text/html" title="Abc" /><published>2021-04-06T00:00:00+08:00</published><updated>2021-04-06T00:00:00+08:00</updated><id>http://www.j10.monster/2021/04/06/abc</id><content type="html" xml:base="http://www.j10.monster/2021/04/06/abc.html">&lt;h1 id=&quot;document-title&quot;&gt;Document Title&lt;/h1&gt;</content><author><name>Just1earnm0re</name></author><summary type="html">Document Title</summary></entry><entry><title type="html">Jekyll and Org together</title><link href="http://www.j10.monster/2021/03/20/test.html" rel="alternate" type="text/html" title="Jekyll and Org together" /><published>2021-03-20T00:00:00+08:00</published><updated>2021-03-20T00:00:00+08:00</updated><id>http://www.j10.monster/2021/03/20/test</id><content type="html" xml:base="http://www.j10.monster/2021/03/20/test.html">&lt;p&gt;&lt;a href=&quot;asda&quot;&gt;dsa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;abc&quot;&gt;asd&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;abc&lt;/h1&gt;
&lt;h2&gt;test&lt;/h2&gt;
&lt;h3&gt;123&lt;/h3&gt;
&lt;h2&gt;test2&lt;/h2&gt;
&lt;h3&gt;321&lt;/h3&gt;
&lt;h2&gt;test3&lt;/h2&gt;
&lt;h3&gt;1&lt;/h3&gt;
&lt;p&gt;123&lt;/p&gt;
&lt;h1&gt;asda&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;abc&quot;&gt;link test 2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;2020-02-11-cmake.md&quot;&gt;file link test&lt;/a&gt;
    &lt;p&gt;&lt;a href=&quot;asda&quot;&gt;link test3&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;&lt;a href=&quot;2020-02-11-cmake.md&quot;&gt;link test4&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=BRqjaN4-gGQ&amp;amp;list=RDCMUCzgkOWKcwy0uhYilE6bd1Lg&amp;amp;index=5&quot;&gt;org mode&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;lk123&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;elisp:(+ 123)&quot;&gt;return 123&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;elisp:org-agenda&quot;&gt;agenda&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;lists&lt;/h1&gt;
&lt;h2&gt;123 [25%]&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;[ ] asd&lt;/li&gt;
  &lt;li&gt;[ ] dsa&lt;/li&gt;
  &lt;li&gt;[X] lkj&lt;/li&gt;
  &lt;li&gt;[ ] jkl&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Just1earnm0re</name></author><category term="test2" /><summary type="html">dsa asd abc test 123 test2 321 test3 1 123 asda link test 2 file link test link test3 link test4 org mode lk123 return 123 agenda lists 123 [25%] [ ] asd [ ] dsa [X] lkj [ ] jkl</summary></entry><entry><title type="html">从源码调试_int_free看how2heap之unlink</title><link href="http://www.j10.monster/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/2020/02/24/how2heap-unlink.html" rel="alternate" type="text/html" title="从源码调试_int_free看how2heap之unlink" /><published>2020-02-24T00:00:00+08:00</published><updated>2020-02-24T00:00:00+08:00</updated><id>http://www.j10.monster/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/2020/02/24/how2heap-unlink</id><content type="html" xml:base="http://www.j10.monster/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/2020/02/24/how2heap-unlink.html">&lt;p&gt;首先说一下个人感受，unlink是个在没有理解的情况下可能完全摸不着头脑的技术点。并且本来就没有搞清楚的东西还没有源码的话，就更头疼了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文首发于&lt;a href=&quot;https://www.anquanke.com/post/id/199552&quot;&gt;安全客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;unlink是个malloc.c文件里的宏，由于是个宏，所以经过编译以后已经inline了，虽然可以找到原始的宏定义，但是看起来毕竟没有那么直观，所以本文从源码调试入手，一次看清unlink的细节。&lt;/p&gt;

&lt;p&gt;几个关键的技术点如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;unlink是在哪个函数里被执行的？&lt;/li&gt;
  &lt;li&gt;unlink的几个参数分别是什么意思？&lt;/li&gt;
  &lt;li&gt;unlink的结果是什么？&lt;/li&gt;
  &lt;li&gt;为什么进行unlink攻击要伪造一个chunk？用原始的chunk只改变fd和bk就不可以吗？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;如何进行源码调试&quot;&gt;如何进行源码调试&lt;/h2&gt;

&lt;h3 id=&quot;首先使用how2heap提供的脚本build出实验需要的225版本的ld和libc如下&quot;&gt;首先使用how2heap提供的脚本build出实验需要的2.25版本的ld和libc，如下：&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./glibc_build.sh &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt;
Usage: ./glibc_build.sh version &lt;span class=&quot;c&quot;&gt;#make-threads&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./glibc_build.sh 2.25 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里编译使用8线程，可以根据CPU情况调高线程数加快编译，整个过程花费时间可能较长。&lt;/p&gt;

&lt;p&gt;如果卡在git clone那一步，建议指定http_proxy并将glibc_build.sh中git clone后的协议改为http。&lt;/p&gt;

&lt;p&gt;编译出的ld和libc会放在glibc_versions目录下，clone下来的源码在glibc_src目录。&lt;/p&gt;

&lt;p&gt;由于这里要进行的是2.25版本的调试，所以如果你依次build了2.25和2.26版本的，请到glibc_src目录下进行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git checkout release/2.25/master&lt;/code&gt;将源文件恢复到2.25版本的状态以便后续调试。&lt;/p&gt;

&lt;h3 id=&quot;接下来修改待调试文件的ld有两种方法可以自由选择&quot;&gt;接下来修改待调试文件的ld,有两种方法，可以自由选择：&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 首先要sudo apt install patchelf，以下两种方法实际上都是用了这个工具。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 1. 使用现成的glibc_run.sh，脚本中含有patch待调试程序的功能。&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./glibc_run.sh 2.25 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;exe]
&lt;span class=&quot;c&quot;&gt;# 2. 直接使用patchelf&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;patchelf &lt;span class=&quot;nt&quot;&gt;--set-interpreter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;path_to_ld] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;exe]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;文件patch好以后，只要在执行或者调试时设置LD_PRELOAD指向相应的libc就可以了。&lt;/p&gt;

&lt;p&gt;如何在GDB中设置LD_PRELOAD可以看我前几天写的&lt;a href=&quot;http://www.j10.monster/二进制安全/2020/02/22/gdb-exec-wrapper.html&quot;&gt;GDB指定被调试程序环境变量&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;简单提一句就是在GDB中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set exec-wrapper env 'LD_PRELOAD=./glibc_versions/libc-2.25.so'&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接下来就可以愉快的进行调试了。调试使用了&lt;a href=&quot;https://github.com/pwndbg/pwndbg&quot;&gt;pwndbg&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;unlink是在哪个函数里被执行的&quot;&gt;unlink是在哪个函数里被执行的？&lt;/h2&gt;

&lt;p&gt;源代码想必点开这篇文章的小伙伴们手里都有，为了突出重点，这里就不贴了。（如果没有快去&lt;a href=&quot;https://github.com/shellphish/how2heap/blob/master/glibc_2.25/unsafe_unlink.c&quot;&gt;这里&lt;/a&gt;看一下&lt;/p&gt;

&lt;p&gt;单步跟踪可以发现chunk0_ptr的值第一次被改变是在第46行的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free(chunk1_ptr)&lt;/code&gt;执行完之后。那么我们先&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b unsafe_unlink.c:46&lt;/code&gt;在执行这一行之前停下，然后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;si&lt;/code&gt;步进。&lt;/p&gt;

&lt;p&gt;在main函数中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call free@plt&lt;/code&gt;之前应该看起来是这个样子:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Snipaste_2020-02-24_11-01-40.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入free函数时看起来应该是这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Snipaste_2020-02-24_11-06-35.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你看到和我一样的界面的话，说明上面的配置没有问题；如果看不到malloc.c的源码的话，建议检查上面哪一步出了问题。（当RIP在free@plt的时候不会看到malloc.c源码，详细信息请搜索“延时绑定、plt”相关内容）&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ni&lt;/code&gt;了几步之后进入了_int_free函数，这也就是我们分析的重点。&lt;/p&gt;

&lt;p&gt;打开malloc.c源文件（在glibc_src/malloc/malloc.c），可以看到_int_free函数中有2处调用了unlink，分别用于后向合并以及前向合并。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Snipaste_2020-02-24_11-47-43.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里要解释一下unlink的各个参数，顺便讲清楚这两个合并分别是什么效果。&lt;/p&gt;

&lt;h2 id=&quot;unlink的几个参数分别是什么意思&quot;&gt;unlink的几个参数分别是什么意思？&lt;/h2&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define unlink(AV, P, BK, FD) {                                            \
    FD = P-&amp;gt;fd;                                                               \
    BK = P-&amp;gt;bk;                                                               \
    if (__builtin_expect (FD-&amp;gt;bk != P || BK-&amp;gt;fd != P, 0))                     \
      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \
    else {                                                                    \
        FD-&amp;gt;bk = BK;                                                          \
        BK-&amp;gt;fd = FD;                                                          \
        if (!in_smallbin_range (P-&amp;gt;size)                                      \
            &amp;amp;&amp;amp; __builtin_expect (P-&amp;gt;fd_nextsize != NULL, 0)) {                \
            // 与本次实验无关                                                    \
            ......                                                            \
          }                                                                   \
      }                                                                       \
}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里截取了相关代码，可以看到FD和BK都比较好理解，P指向将要从双向链表中取下的chunk的头部。&lt;/p&gt;

&lt;p&gt;那么这个AV是什么？可以看到malloc.c中第4019行的unlink的av是由_int_free的参数传入的，&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;_int_free&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mstate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;av&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mchunkptr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;have_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;......&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;看到av的类型是mstate。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc_state&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main_arena&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_LIBC_LOCK_INITIALIZER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main_arena&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attached_threads&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;......&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mstate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ar_ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main_arena&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从mstate的类型可以看出av是一个指向分配区（arena）的指针，那么av可能是arena vector的意思。&lt;/p&gt;

&lt;p&gt;所以这里不需要关心AV这个参数有什么用。&lt;/p&gt;

&lt;p&gt;那再来看看后向合并和前向合并是什么意思？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;后向合并只要free函数指向的chunk的前一个chunk是未使用状态就会触发，用于将物理相邻的前一个chunk与后一个chunk合并，合并的结果是chunk开始于前chunk，大小为两个chunk之和，并且后chunk被unlink宏从双向链表中取下。&lt;/li&gt;
  &lt;li&gt;前向合并只有检测到下一个chunk不是当前分配区的topchunk并且是未使用状态才会触发，合并结果是将后chunk合并入前chunk，新的chunk开始于前chunk，大小为两个chunk之和。若下一个chunk就是topchunk，则直接将当前chunk变为topchunk。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过前面对于chunk1_ptr指向的chunk1的metadata的修改，_int_free会认为我们在chunk0_ptr指向的chunk0中伪造的chunk是未使用状态，因此会将这个fake chunk的开始地址也就是chunk1_hdr-0x80作为unlink宏的P的值，以此触发unlink。&lt;/p&gt;

&lt;h2 id=&quot;unlink的结果是什么&quot;&gt;unlink的结果是什么？&lt;/h2&gt;

&lt;p&gt;我们从malloc.c第4015行的后向合并开始：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Snipaste_2020-02-24_15-00-32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;0x7ffff7ab4710 &amp;lt;_int_free+416&amp;gt;    test   byte ptr [rbx + 8], 1
=&amp;gt; rbx= p =0x555555758090

0x7ffff7ab4716 &amp;lt;_int_free+422&amp;gt;    mov    rax, qword ptr [rbx]
=&amp;gt; rax=0x80

0x7ffff7ab4719 &amp;lt;_int_free+425&amp;gt;    sub    rbx, rax
=&amp;gt; rbx -= 0x80
=&amp;gt; rbx= p =0x555555758010  &amp;lt;-------------- fake mchunkptr

0x7ffff7ab471c &amp;lt;_int_free+428&amp;gt;    add    r12, rax
=&amp;gt; r12= size =size+prevsize=r12+rax=0x90+0x80=0x110
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上几行设置好了P为fake chunk的开始地址以及chunk大小，接下来第4019行开始unlink：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Snipaste_2020-02-24_14-49-19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;-------------------unlink-------------------
0x7ffff7ab471f &amp;lt;_int_free+431&amp;gt;    mov    rax, qword ptr [rbx + 0x10]
=&amp;gt; rax= FD =p-&amp;gt;fd=0x555555756018

0x7ffff7ab4723 &amp;lt;_int_free+435&amp;gt;    mov    rdx, qword ptr [rbx + 0x18]
=&amp;gt; rdx= BK =p-&amp;gt;bk=0x555555756020

0x7ffff7ab4727 &amp;lt;_int_free+439&amp;gt;    cmp    qword ptr [rax + 0x18], rbx
=&amp;gt; test FD-&amp;gt;bk==p

0x7ffff7ab4731 &amp;lt;_int_free+449&amp;gt;    cmp    qword ptr [rdx + 0x10], rbx
=&amp;gt; test BK-&amp;gt;fd==p

0x7ffff7ab473b &amp;lt;_int_free+459&amp;gt;    cmp    qword ptr [rbx + 8], 0x3ff
=&amp;gt; test p-&amp;gt;size&amp;gt;small_bin_range

0x7ffff7ab4743 &amp;lt;_int_free+467&amp;gt;    mov    qword ptr [rax + 0x18], rdx
=&amp;gt; FD-&amp;gt;bk = BK
=&amp;gt; qword ptr [0x555555756030] = 0x555555756020

0x7ffff7ab4747 &amp;lt;_int_free+471&amp;gt;    mov    qword ptr [rdx + 0x10], rax
=&amp;gt; BK-&amp;gt;fd = FD
=&amp;gt; qword ptr [0x555555756030] = 0x555555756018
=&amp;gt; qword ptr [&amp;amp;chunk0_ptr] = ((char *)&amp;amp;chunk0_ptr)-0x18

p-&amp;gt;size in small_bin_range, so unlink finish.
-----------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里unlink设置好FD以及BK，并且测试完&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FD-&amp;gt;bk==p&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BK-&amp;gt;fd==p&lt;/code&gt;之后，就开始了原本应该将该chunk从双向链表取下的操作，而攻击正是发生在这里。&lt;/p&gt;

&lt;p&gt;由于FD-&amp;gt;bk与BK-&amp;gt;fd指向的都是变量chunk0_ptr所在的内存地址，因此对这两个指针的赋值其实都是直接改变了chunk0_ptr的值，由于是往同一个地方写入，第二次赋值为FD会覆盖第一次赋值为BK的效果，最终结果就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chunk0_ptr=(&amp;amp;chunk0_ptr)-3&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;此时再使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chunk0_ptr[3]=0xdeadbeef&lt;/code&gt;这种写法就可以将chunk0_ptr的值覆写为任意想要的地址。&lt;/p&gt;

&lt;p&gt;实验最后是将chunk0_ptr覆写为了一个字符串的地址并且更改了字符串的内容，攻击完成。&lt;/p&gt;

&lt;h2 id=&quot;为什么进行unlink攻击要伪造一个chunk&quot;&gt;为什么进行unlink攻击要伪造一个chunk？&lt;/h2&gt;

&lt;p&gt;有小伙伴可能要问：“我看实验步骤里有一个伪造chunk的过程，改变了前一个chunk的大小，那我不改这个大小，直接把fd和bk的值填进chunk0_ptr[0]、[1]行不行？”&lt;/p&gt;

&lt;p&gt;结果是不行的。由于有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FD-&amp;gt;bk==p&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BK-&amp;gt;fd==p&lt;/code&gt;这两个检测的设定，并且&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FD-&amp;gt;bk&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BK-&amp;gt;fd&lt;/code&gt;指向的都是chunk0_ptr所在地址，相当于p必须等于chunk0_ptr的值，即实验中伪造的chunk的开始地址，差一个字节都不行。&lt;/p&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;好了，分析到这里就结束了，这个攻击方法虽然对&amp;gt;2.25版本的glibc都无效，但是其中的很多细节都是值得学习的，希望各位看得开心，有什么问题可以一起讨论鸭。&lt;/p&gt;</content><author><name>Just1earnm0re</name></author><category term="二进制安全" /><category term="how2heap" /><category term="unlink" /><category term="chunk" /><category term="源码" /><summary type="html">首先说一下个人感受，unlink是个在没有理解的情况下可能完全摸不着头脑的技术点。并且本来就没有搞清楚的东西还没有源码的话，就更头疼了。</summary></entry><entry><title type="html">GDB指定被调试程序环境变量</title><link href="http://www.j10.monster/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/2020/02/22/gdb-exec-wrapper.html" rel="alternate" type="text/html" title="GDB指定被调试程序环境变量" /><published>2020-02-22T00:00:00+08:00</published><updated>2020-02-22T00:00:00+08:00</updated><id>http://www.j10.monster/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/2020/02/22/gdb-exec-wrapper</id><content type="html" xml:base="http://www.j10.monster/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/2020/02/22/gdb-exec-wrapper.html">&lt;p&gt;当碰到一个程序需要指定版本的ld以及libc的情况，在命令行直接运行比较简单：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;patchelf&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--set-interpreter&lt;/code&gt;功能就可以对文件进行patch以指定ld。&lt;/li&gt;
  &lt;li&gt;经过第一步patch文件后，运行程序时配合LD_PRELOAD指定libc即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是想用GDB获得同样的体验就比较麻烦。&lt;/p&gt;

&lt;h4 id=&quot;set-env-无效&quot;&gt;set env 无效&lt;/h4&gt;

&lt;p&gt;简单的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(gdb) set env LD_PRELOAD=&quot;xxx&quot;&lt;/code&gt;没有达到预期，连程序都跑不起来。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pwndbg&amp;gt; &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;environment LD_PRELOAD ./glibc_versions/libc-2.25.so
pwndbg&amp;gt; start
Exception occurred: entry: During startup program terminated with signal SIGSEGV, Segmentation fault. &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&amp;lt;class &lt;span class=&quot;s1&quot;&gt;'gdb.error'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;
For more info invoke &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;exception-verbose on&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; and rerun the &lt;span class=&quot;nb&quot;&gt;command
&lt;/span&gt;or debug it by yourself with &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;exception-debugger on&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
^CQuit
pwndbg&amp;gt; &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;exception-verbose on
Set whether to print a full stacktracefor exceptions raised &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;Pwndbg commands to True
pwndbg&amp;gt; start
Traceback &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;most recent call last&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
  File &lt;span class=&quot;s2&quot;&gt;&quot;/home/fp/pwndbg/pwndbg/commands/__init__.py&quot;&lt;/span&gt;, line 136, &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;__call__
    &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;self.function&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;args, &lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;kwargs&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  File &lt;span class=&quot;s2&quot;&gt;&quot;/home/fp/pwndbg/pwndbg/commands/__init__.py&quot;&lt;/span&gt;, line 216, &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;_OnlyWithFile
    &lt;span class=&quot;k&quot;&gt;return function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;a, &lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;kw&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  File &lt;span class=&quot;s2&quot;&gt;&quot;/home/fp/pwndbg/pwndbg/commands/start.py&quot;&lt;/span&gt;, line 95, &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;entry
    gdb.execute&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;run, &lt;span class=&quot;nv&quot;&gt;from_tty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;False&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
gdb.error: During startup program terminated with signal SIGSEGV, Segmentation fault.

If that is an issue, you can report it on https://github.com/pwndbg/pwndbg/issues
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Please don&lt;span class=&quot;s1&quot;&gt;'t forget to search if it hasn'&lt;/span&gt;t been reported before&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
To generate the report and open a browser, you may run &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;bugreport &lt;span class=&quot;nt&quot;&gt;--run-browser&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
PS: Pull requests are welcome
^CQuit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;解决方案&quot;&gt;解决方案&lt;/h4&gt;

&lt;p&gt;解决方案来自&lt;a href=&quot;https://stackoverflow.com/a/41822591&quot;&gt;stackoverflow&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(gdb) set exec-wrapper env 'LD_PRELOAD=./glibc_versions/libc-2.25.so'&lt;/code&gt;即可指定libc文件。&lt;/p&gt;

&lt;p&gt;实际效果如下：&lt;/p&gt;

&lt;script id=&quot;asciicast-z5RvTWuimlGborC5fBqeayRQM&quot; src=&quot;https://asciinema.org/a/z5RvTWuimlGborC5fBqeayRQM.js&quot; async=&quot;&quot;&gt;&lt;/script&gt;</content><author><name>Just1earnm0re</name></author><category term="二进制安全" /><category term="gdb" /><category term="环境变量" /><category term="LD_PRELOAD" /><summary type="html">当碰到一个程序需要指定版本的ld以及libc的情况，在命令行直接运行比较简单：</summary></entry><entry><title type="html">Jekyll本地预览看不到刚写的post</title><link href="http://www.j10.monster/%E5%8D%9A%E5%AE%A2/2020/02/22/jekyll-post-disappear.html" rel="alternate" type="text/html" title="Jekyll本地预览看不到刚写的post" /><published>2020-02-22T00:00:00+08:00</published><updated>2020-02-22T00:00:00+08:00</updated><id>http://www.j10.monster/%E5%8D%9A%E5%AE%A2/2020/02/22/jekyll-post-disappear</id><content type="html" xml:base="http://www.j10.monster/%E5%8D%9A%E5%AE%A2/2020/02/22/jekyll-post-disappear.html">&lt;p&gt;今天刚写了一篇post，想本地预览一下效果，结果神奇的事情出现了……&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bundle exec jekyll serve&lt;/code&gt;一顿操作，然后，么的动静，仿佛这一篇文章从未出现过。&lt;img src=&quot;/assets/images/2020-2-22-bq.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然鹅直接扔给github-pages却是可以正常显示的。&lt;/p&gt;

&lt;p&gt;我又创建了几个测试的post，改改文件名，甚至一度以为是因为我文件名里有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec&lt;/code&gt;这种玩意儿被过滤掉了，但是当我把文件名写成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt;都不行的时候，发现事情并不简单。&lt;img src=&quot;/assets/images/2020-2-22-bq.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为jekyll默认是根据文件名来判断日期的，所以又改了下文件名里的日期，神奇的事情又出现了……&lt;/p&gt;

&lt;p&gt;UTC+8现在是2020年2月22日周六，但是经过测试只有文件名是21号及以前的才显示，难道我一不小心贡献出了一些时间？&lt;img src=&quot;/assets/images/2020-2-22-bq.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;吓得我赶紧打开了详细信息看一下啥情况，结果出来了，还好，时间没有贡献掉：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Snipaste_2020-02-22_13-57-59.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于我虚拟机的时区用了默认的，时间才21号周五，jekyll跳过了未来日期的post，自然就看不到了。&lt;/p&gt;

&lt;p&gt;破案了，完结撒花。&lt;img src=&quot;/assets/images/2020-2-22-bq.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Just1earnm0re</name></author><category term="博客" /><category term="Jekyll" /><category term="时间" /><summary type="html">今天刚写了一篇post，想本地预览一下效果，结果神奇的事情出现了……</summary></entry><entry><title type="html">Tcache index计算以及CHUNKSIZE大小</title><link href="http://www.j10.monster/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/2020/02/21/tcache-idx.html" rel="alternate" type="text/html" title="Tcache index计算以及CHUNKSIZE大小" /><published>2020-02-21T00:00:00+08:00</published><updated>2020-02-21T00:00:00+08:00</updated><id>http://www.j10.monster/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/2020/02/21/tcache-idx</id><content type="html" xml:base="http://www.j10.monster/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/2020/02/21/tcache-idx.html">&lt;p&gt;本文为基础内容。&lt;/p&gt;

&lt;p&gt;根据&lt;a href=&quot;https://github.com/shellphish/how2heap/blob/master/calc_tcache_idx.c&quot;&gt;how2heap&lt;/a&gt;上描述的Tcache index计算规则，即：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define request2size(req)                                         \
  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &amp;lt; MINSIZE)  ?             \
   MINSIZE :                                                      \
   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp;amp; ~MALLOC_ALIGN_MASK)
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* When &quot;x&quot; is from chunksize().  */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* When &quot;x&quot; is a user-provided size.  */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;# define usize2tidx(x) csize2tidx (request2size (x))
&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;宏&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;usize2tidx&lt;/code&gt;用于计算IDX的值，可以看到分两步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用request2size将用户输入的数值转换为CHUNKSIZE&lt;/li&gt;
  &lt;li&gt;用csize2tidx将CHUNKSIZE转换为IDX&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;request2size&quot;&gt;request2size：&lt;/h4&gt;

&lt;p&gt;在64位机器上，SIZE_SZ=0x8，MALLOC_ALIGN_MASK=0xf，MINSIZE=0x20&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp;amp; ~MALLOC_ALIGN_MASK)&lt;/code&gt;在这里用于将用户请求的值x加上8之后进行16字节向上取整。&lt;/p&gt;

&lt;p&gt;可以根据规则计算得出，x&amp;lt;=0x18时，CHUNKSIZE均为0x20；0x19~0x28为0x30，以此类推。&lt;/p&gt;

&lt;h4 id=&quot;csize2tidx&quot;&gt;csize2tidx：&lt;/h4&gt;

&lt;p&gt;在得到CHUNKSIZE后，计算IDX十分简单，只要将CHUNKSIZE减去0x11然后使用MALLOC_ALIGNMENT整除即可。&lt;/p&gt;</content><author><name>Just1earnm0re</name></author><category term="二进制安全" /><category term="how2heap" /><category term="tcache" /><category term="chunk" /><summary type="html">本文为基础内容。</summary></entry><entry><title type="html">使用CMake为每一个C文件生成可执行对象</title><link href="http://www.j10.monster/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/2020/02/11/cmake.html" rel="alternate" type="text/html" title="使用CMake为每一个C文件生成可执行对象" /><published>2020-02-11T00:00:00+08:00</published><updated>2020-02-11T00:00:00+08:00</updated><id>http://www.j10.monster/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/2020/02/11/cmake</id><content type="html" xml:base="http://www.j10.monster/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/2020/02/11/cmake.html">&lt;p&gt;由于CLion似乎对CMake的友好度更高，所以将原有的使用Makefile的工作方式改为CMake。
原项目结构如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;how2heap/
	Makefile
	{source_files}.c
	...
	glibc_2.25/
		{source_files}.c
	glibc_2.26/
		{source_files}.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;原有的Makefile内容如下，功能就是为每个C源文件单独生成一个可执行文件。&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; fastbin_dup malloc_playground first_fit calc_tcache_idx
&lt;span class=&quot;nv&quot;&gt;V2.25&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; glibc_2.25/fastbin_dup_into_stack glibc_2.25/fastbin_dup_consolidate glibc_2.25/unsafe_unlink glibc_2.25/house_of_spirit glibc_2.25/poison_null_byte glibc_2.25/house_of_lore glibc_2.25/overlapping_chunks glibc_2.25/overlapping_chunks_2 glibc_2.25/house_of_force glibc_2.25/large_bin_attack glibc_2.25/unsorted_bin_attack glibc_2.25/unsorted_bin_into_stack glibc_2.25/house_of_einherjar glibc_2.25/house_of_orange
&lt;span class=&quot;nv&quot;&gt;V2.26&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; glibc_2.26/unsafe_unlink glibc_2.26/house_of_lore glibc_2.26/overlapping_chunks glibc_2.26/large_bin_attack glibc_2.26/unsorted_bin_attack glibc_2.26/unsorted_bin_into_stack glibc_2.26/house_of_einherjar glibc_2.26/tcache_dup glibc_2.26/tcache_poisoning glibc_2.26/tcache_house_of_spirit
&lt;span class=&quot;nv&quot;&gt;PROGRAMS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(BASE)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(V2.25)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(V2.26)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;CFLAGS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;c99 &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Convenience to auto-call mcheck before the first malloc()
#CFLAGS += -lmcheck
&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;$(PROGRAMS)&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(PROGRAMS)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果要使用CMake的写法，那么有下面几步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在所有存在源代码的目录下创建一个CMakeLists.txt，比如在how2heap,glibc_2.25和glibc_2.26这三个文件夹下各创建一个CMakeLists.txt。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;编辑每个CMakeLists.txt，用来指导生成所在文件夹源文件对应的可执行文件。&lt;/li&gt;
  &lt;li&gt;使用CLion进行build等操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显然重点是第2步，下面分层次对CMakeLists.txt进行说明。&lt;/p&gt;

&lt;h2 id=&quot;顶层cmakeliststxt&quot;&gt;顶层CMakeLists.txt&lt;/h2&gt;

&lt;p&gt;项目根目录下的CMakeLists.txt如下所示：&lt;/p&gt;

&lt;div class=&quot;language-cmake highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;how2heap&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;cmake_minimum_required&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;VERSION 3.14&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;CMAKE_C_FLAGS &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_C_FLAGS&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; -std=c99 -g&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;CMAKE_VERBOSE_MAKEFILE TRUE&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -lmcheck&quot;)&lt;/span&gt;


&lt;span class=&quot;nb&quot;&gt;aux_source_directory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;. topdir&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;src &lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;topdir&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;REGEX MATCH &lt;span class=&quot;s2&quot;&gt;&quot;[A-Za-z0-9_]+&quot;&lt;/span&gt; exe &lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;add_executable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exe&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;endforeach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;


&lt;span class=&quot;nb&quot;&gt;add_subdirectory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;glibc_2.25&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;add_subdirectory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;glibc_2.26&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先简单说明CMakeLists.txt中的变量定义与使用方法，变量定义直接写标识符即可，变量引用要写成${变量}这种形式。&lt;/p&gt;

&lt;p&gt;只说重点，其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aux_source_directory&lt;/code&gt;用于将本CMakeLists.txt所在文件夹&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt;（不包括子文件夹）下的所有源文件的路径以字符串构成的列表形式存进变量&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topdir&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foreach&lt;/code&gt;…&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;endforeach&lt;/code&gt;语句写成Python就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for src in topdir&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;string&lt;/code&gt;函数正则匹配了源文件名无后缀的内容并赋值给变量&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exe&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_executable&lt;/code&gt;将可执行目标文件名（项目内不可重名）以及基于的源文件名注册进当前项目。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_subdirectory&lt;/code&gt;表示CMake会处理指定的文件夹中的CMakeLists.txt。&lt;/p&gt;

&lt;h2 id=&quot;子cmakeliststxt&quot;&gt;子CMakeLists.txt&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;文件夹glibc_2.25中的CMakeLists.txt如下，相比顶层的CMakeLists.txt简洁许多。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-cmake highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;aux_source_directory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;. v25dir&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# v26dir in glibc_2.26&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;src &lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;v25dir&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;REGEX REPLACE &lt;span class=&quot;s2&quot;&gt;&quot;./([A-Za-z0-9_]+).c&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1_v25&quot;&lt;/span&gt; exe &lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;add_executable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;exe&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;endforeach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于在CMakeLists.txt中定义的变量似乎都是全局变量（来自经验，未查证），所以如果在这里&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aux_source_directory&lt;/code&gt;中还是写topdir而不是换一个名字比如v25dir，那么CMake会报类似&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;找不到fastbin_dup.c&lt;/code&gt;（项目根目录下的一个文件）这种错误。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;string&lt;/code&gt;函数选择了正则模式的替换功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第一个正则式匹配了整个src变量，并且使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt;语法将需要的可执行文件名提取了出来。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二个正则式使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\\1&lt;/code&gt;引用了上面使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt;提取出来的内容，然后加上后缀。（由于glibc_2.25和glibc_2.26文件夹中存在很多文件名完全相同的文件，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_executable&lt;/code&gt;不允许重名，所以分别在末尾加上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_v25&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_v26&lt;/code&gt;加以区别而不是像顶层的CMakeLists.txt那样进行简单的匹配。）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;文件夹glibc_2.26中的CMakeLists.txt类似，进行相应修改即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此应该没有问题，可以使用CLion来build以及clean了。&lt;/p&gt;</content><author><name>Just1earnm0re</name></author><category term="项目管理" /><category term="CMake" /><category term="Makefile" /><category term="CLion" /><summary type="html">由于CLion似乎对CMake的友好度更高，所以将原有的使用Makefile的工作方式改为CMake。 原项目结构如下：</summary></entry></feed>